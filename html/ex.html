<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>review.json 빈 photo 자동 채우기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    h1 { font-size: 20px; margin-bottom: 8px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 12px 0 16px; }
    button { padding: 8px 12px; border: 1px solid #ccc; background: #fafafa; border-radius: 8px; cursor: pointer; }
    button:hover { background: #f0f0f0; }
    .stat { font-size: 14px; color: #374151; margin: 8px 0 0; }
    .warn { color: #b45309; font-size: 13px; }
    pre { background: #0b1020; color: #d7e7ff; padding: 16px; border-radius: 8px; overflow: auto; max-height: 55vh; }
  </style>
</head>
<body>
  <h1>review.json 빈 <code>photo</code> 자동 채움</h1>
  <p class="warn">브라우저에서 로컬 파일을 직접 덮어쓰는 건 제한이 있어요. <b>다운로드 저장</b> 또는 <b>File System Access API(지원 브라우저)</b>로 저장을 제공합니다.</p>

  <div class="row">
    <button id="btn-run">실행: 비어있는 photo 채우기</button>
    <button id="btn-download" disabled>다운로드로 저장</button>
    <button id="btn-save-fsa" disabled>원본 파일로 저장(실험적)</button>
  </div>

  <div id="stats" class="stat">상태: 대기 중</div>
  <pre id="output">(여기에 변경된 JSON이 미리보기로 표시됩니다)</pre>

  <script>
    const JSON_PATH = "../json/review.json"; // 원본 경로

    // ---- 1) 가게명으로 사진 경로 추정 ----
    function inferPhotoByStoreName(name = "") {
      const n = name.toLowerCase();
      if (n.includes("초밥")) return "../img/chobab.jpg";
      if (n.includes("삼계탕")) return "../img/samgyetang.jpg";
      if (n.includes("설렁탕")) return "../img/sullungtang.jpg";
      if (n.includes("닭한마리")) return "../img/chickenSoup.jpg";
      if (n.includes("갈비")) return "../img/galbi.jpg";
      if (n.includes("돈까스") || n.includes("돈가스")) return "../img/donkkas.jpg";
      if (n.includes("짜장")) return "../img/jjajangmeon.jpg";
      if (n.includes("만두") || n.includes("교자")) return "../img/mandu.jpg";
      if (n.includes("칼국수")) return "../img/calguksu.jpg";
      if (n.includes("냉면")) return "../img/nengmeon.jpg";
      if (n.includes("분식") || n.includes("떡볶이")) return "../img/bunsik.jpg";
      if (n.includes("순대")) return "../img/sundae.jpg";
      if (n.includes("찜닭")) return "../img/jjimdak.jpg";
      if (n.includes("족발")) return "../img/porkFeet.jpg";
      if (n.includes("해장국") || n.includes("국밥")) return "../img/gukbab.jpg";
      if (n.includes("골뱅")) return "../img/golbang.jpg";
      if (n.includes("라멘")) return "../img/ramen.jpg";
      if (n.includes("막국수")) return "../img/makguksu.jpg";
      if (n.includes("비빔밥")) return "../img/bibimbab.jpg";
      if (n.includes("파스타")) return "../img/pasta.jpg";
      if (n.includes("카페") || n.includes("커피")) return "../img/coffee.jpg";
      if (n.includes(" 바") || n.endsWith("바")) return "../img/bar.jpg";
      return "../img/default.jpg"; // 기본 이미지 준비 권장
    }

    // ---- 2) 비어있는 photo만 채우기 ----
    function fillMissingPhotos(data) {
      let filledCount = 0;
      const filledData = data.map(store => {
        const guess = inferPhotoByStoreName(store?.name || "");
        const reviews = (store.reviews || []).map(r => {
          const empty = !r.photo || String(r.photo).trim() === "";
          if (empty) filledCount++;
          return empty ? { ...r, photo: guess } : r;
        });
        return { ...store, reviews };
      });
      return { filledData, filledCount };
    }

    // ---- 3) 불러오기 → 채우기 → 미리보기/버튼활성 ----
    let latestText = "";
    document.getElementById("btn-run").addEventListener("click", async () => {
      const stats = document.getElementById("stats");
      const out = document.getElementById("output");
      stats.textContent = "상태: review.json 불러오는 중…";

      try {
        const res = await fetch(JSON_PATH, { cache: "no-store" });
        if (!res.ok) throw new Error("네트워크 오류: " + res.status);
        const raw = await res.json();

        // 채우기 실행
        const { filledData, filledCount } = fillMissingPhotos(raw);
        latestText = JSON.stringify(filledData, null, 2);

        // 미리보기 + 통계
        out.textContent = latestText;
        stats.textContent = `완료: 비어있던 photo ${filledCount}개 채움. 총 가게 ${filledData.length}개.`;

        // 저장 버튼 활성화
        document.getElementById("btn-download").disabled = false;
        document.getElementById("btn-save-fsa").disabled = !("showOpenFilePicker" in window && "showSaveFilePicker" in window);
      } catch (e) {
        console.error(e);
        stats.textContent = "오류: " + e.message;
      }
    });

    // ---- 4A) 다운로드로 저장 (원본은 건드리지 않음) ----
    document.getElementById("btn-download").addEventListener("click", () => {
      if (!latestText) return;
      const blob = new Blob([latestText], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "review.updated.json"; // 필요시 review.json으로 교체해서 덮어쓰기
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // ---- 4B) (실험적) File System Access API로 원본 파일 열어 덮어쓰기 ----
    // 크롬/엣지 + HTTPS 또는 localhost 환경에서 가능
    document.getElementById("btn-save-fsa").addEventListener("click", async () => {
      if (!latestText) return;
      try {
        // 1) 원본 파일 선택(최초 1회) → 2) 같은 핸들로 쓰기
        const [handle] = await window.showOpenFilePicker({
          types: [{ description: "JSON", accept: { "application/json": [".json"] } }],
          excludeAcceptAllOption: false,
          multiple: false
        });
        const writable = await handle.createWritable();
        await writable.write(latestText);
        await writable.close();
        alert("원본 파일에 저장 완료!");
      } catch (e) {
        console.error(e);
        alert("저장 실패: " + e.message);
      }
    });
  </script>
</body>
</html>
